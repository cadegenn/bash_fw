## @file efunctions.rc
## @brief librarie for e*() functions that do not depend on OS
## @author Charles-Antoine Degennes <cadegenn@gmail.com>
## @copyright	(c) 2017 Charles-Antoine Degennes <cadegenn@gmail.com>

## @fn ebegin()
## @brief display begin message
## @param $message  the message to display
ebegin() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_BEGIN_COLOR} *${COLOR_NORMAL} ${message} " >> ${STDOUT}
}

## @fn ebreak()
## @brief print a break line
ebreak() {
	[ ! "${COLUMNS}" ] && COLUMNS=$(tput cols)
	echo
	for i in $(seq ${COLUMNS}); do echo -n '-' >> ${STDOUT}; done
}

## @fn edebug()
## @brief display debug message
## @param $message  the message to display
edebug() {
	if [ ${DEBUG} ]; then
		echo -ne "\n${INDENT}${THEME_DEBUG_COLOR} * DBG: $@${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn edevel()
## @brief display message to help development
## @param $message  the message to display
edevel() {
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_DEVEL_COLOR} * DEV: $@${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn eend()
## @brief display end message
## @param $rc  the status code to display
## @see returncodes.rc
eend() {
	local rc=${1}
	[ ! "${COLUMNS}" ] && COLUMNS=$(tput cols)
	esetx $((COLUMNS - ${#rc_done} - 16))
	case ${rc} in
		${RC_DONE})	 echo -ne "${rc_done}" >> ${STDOUT}
						;;
		${RC_FAILED})   echo -ne "${rc_failed}" >> ${STDOUT}
						;;
		${RC_RUNNING})  echo -ne "${rc_running}" >> ${STDOUT}
						;;
		${RC_MISSED})   echo -ne "${rc_missed}" >> ${STDOUT}
						;;
		${RC_SKIPPED})  echo -ne "${rc_skipped}" >> ${STDOUT}
						;;
		${RC_UNUSED})   echo -ne "${rc_unused}" >> ${STDOUT}
						;;
		${RC_UNKNOWN})  echo -ne "${rc_unknown}" >> ${STDOUT}
						;;
		${RC_DEAD})	 echo -ne "${rc_dead}" >> ${STDOUT}
						;;
		*)			  echo -ne "${rc_unknown}" >> ${STDOUT}
						;;
	esac

}

## @fn eenter()
## @brief display message when entering something (a function for example or a loop)
## @param $message  the message to display
eenter() {
	local message=${@}
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_ENTER_COLOR} >> ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn eerror()
## @brief display error message
## @param $message  the error message to display
eerror() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_ERROR_COLOR} * ERR: ${message} ${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn efatal()
## @brief display error message and exit
## @param $message  the error message to display
efatal() {
	eerror "$@\n"
	exit 1
}

## @fn einfo()
## @brief display info message
## @param $message  the message to display
einfo() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_INFO_COLOR} *${COLOR_NORMAL} ${message}" >> ${STDOUT}
}

## @fn eleave()
## @brief display message when leaving something (a function for example or a loop)
## @param $message  the message to display
eleave() {
	local message=${@}
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_ENTER_COLOR} << ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn esubtitle()
## @brief display begin message
## @param $message  the message to display
esubtitle() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_TITLE_COLOR} * ${THEME_SUBTITLE_COLOR}${message}${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn etitle()
## @brief display a title
## @param $message  the title to display
etitle() {
	local message=${@}
	echo -e -n "\n${THEME_TITLE_COLOR} " >> ${STDOUT}
	for i in $(seq $((${#message}+6))); do echo -n '*'; done
	echo -e "\n ** ${message} ** ${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn everbose()
## @brief display verbose message
## @param $message  the message to display
everbose() {
	local message=${@}
	if [ ${VERBOSE} ]; then
		echo -ne "\n${INDENT}${THEME_VERBOSE_COLOR} * ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn ewarn()
## @brief display warning message
## @param $message  the warning to display
ewarn() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_WARNING_COLOR} * ${message} ${COLOR_NORMAL}" >> ${STDOUT}
}

# ---------------------------------------------------------------------------------------

## @fn egetx()
## @brief get x position of current cursor
## @return (integer) current x position of cursor in terminal
## @see @url https://unix.stackexchange.com/questions/88296/get-vertical-cursor-position
egetx() {
	exec < /dev/tty
	oldstty=$(stty -g)
	stty raw -echo min 0
	## on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	## tput u7 > /dev/tty	# when TERM=xterm (and relatives)
	IFS=';' read -r -d R -a pos
	stty $oldstty
	## change from one-based to zero based so they work with: tput cup $row $col
	#row=$((${pos[0]:2} - 1))	# strip off the esc-[
	col=$((${pos[1]} - 1))

	#echo "(row,col): $row,$col"
	echo ${col}
}

## @fn esetx()
## @brief set x position of current cursor
## @param $x new position to set cursor to
## @see @url http://ascii-table.com/ansi-escape-sequences.php
esetx() {
	local new_x=${1}
	local cur_x=$(egetx)

	[ ! ${new_x} -ge 0 ] && return
	[ ! ${cur_x} -ge 0 ] && return

	if [ ${new_x} -gt ${cur_x} ]; then
		local step=$((new_x - cur_x))
		#echo -e "\033[${step}C ${new_x}"
		tput cuf ${step}
	else
		local step=$((cur_x - new_x))
		#echo -e "${new_x} \033[${step}D"
		tput cub ${step}
	fi
}

# ---------------------------------------------------------------------------------------

## @fn eexec()
## @brief execute command
## @param $cmd	full command line with parameters
## @return (integer)	return code
eexec() {
	local CMD="$*"
	#[ "${DEBUG}" ] && ${LOGGER} ${LOGGER_OPTIONS} -p ${FACILITY}.debug "DEBUG: ${CMD}"
	if [ "${ASK}" ]; then
		local ANSWER=$(equestion_yn "execute \"${CMD}\" ?" 'y')
		[ ! "${ANSWER}" ] && return 0
	fi
	edebug "${CMD}" >> ${STDOUT}
	[ "${SIMULATE}" ] && eend ${RC_UNUSED} && return 0
	if [ "${DEVEL}" ]; then
		echo -ne "\n${THEME_DEVEL_COLOR}"
		eval ${CMD}
	elif [ "${DEBUG}" ]; then
		echo -ne "${THEME_DEBUG_COLOR}"
		(eval ${CMD}) > /dev/null
	else
		(eval ${CMD}) > /dev/null 2>&1
	fi
	echo -ne ${COLOR_NORMAL}
	#echo ${CMD}
	#exec ${CMD}
	local RC=$?
	#[ -f "${OUTPUT}" ] && [ ${VERBOSE} -gt 1 ] && ${LOGGER} ${LOGGER_OPTIONS} -p ${FACILITY}.info -f "${OUTPUT}" && rm -f "${OUTPUT}"
	[ "${DEBUG}" ] && eend ${RC}
	return ${RC}
}

# ---------------------------------------------------------------------------------------

## @fn equestion()
## @brief print a question
## @param $message The question itself
## @param $default Optional: the default answer. It will be displayed between angle brackets.
## @param $is_passwd  Optional: if set to true, do not echo user input. Usefull for asking password
## @return (string) response from the user
equestion() {
	local message="${1}"
	local answer="${2}"
	local passwd="${3}"
    echo -ne "\n${INDENT}${THEME_QUESTION_COLOR} * QUE: ${message} ${COLOR_NORMAL}" >> ${TTY}
	[ "${answer}" ] && echo -ne "[${THEME_QUESTION_DEFAULT_ANSWER_COLOR}${answer}${COLOR_NORMAL}] " >> ${TTY}

	# -y or -yes was specified on command line
    [ "${YES}" ] && echo ${answer} && return

	[ "${passwd}" ] && read -s REPONSE || read REPONSE
	echo ${REPONSE:-${answer}}
}

## @fn equestion_yn()
## @brief print a boolean question
## @param $message The question itself
## @param $default Optional: the default answer. It has to by 'y' or 'n'
## @return (string) response from the user
equestion_yn() {
	local message="${1}"
	local answer="${2}"
	case ${answer} in
		[yY]*|1|[tT][rR][uU][eE])
				answer="y"
				;;
		*)		answer="n"
				;;
	esac
	local REPONSE=$(equestion "${message}" "${answer}")
	case ${REPONSE,,} in
		y|o|1|true)
			echo "y"
			;;
		*)	echo
			;;
	esac
}

## @fn equestion_passwd()
## @brief ask for a passwd
## @param $message The question itself
## @return (string) response from the user
equestion_passwd() {
	local message="${1}"
	equestion "${message}" "" true
}

