## @file efunctions.rc
## @brief librarie for e*() functions that do not depend on OS
## @author Charles-Antoine Degennes <cadegenn@gmail.com>
## @copyright	(c) 2017 Charles-Antoine Degennes <cadegenn@gmail.com>

## @fn ebegin()
## @brief display begin message
## @param $message  the message to display
ebegin() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_BEGIN_COLOR} *${COLOR_NORMAL} ${message} " >> ${STDOUT}
}

## @fn ebreak()
## @brief print a break line
ebreak() {
	[ ! "${COLUMNS}" ] && COLUMNS=$(tput cols)
	echo
	for i in $(seq ${COLUMNS}); do echo -n '-' >> ${STDOUT}; done
}

## @fn edebug()
## @brief display debug message
## @param $message  the message to display
edebug() {
	if [ ${DEBUG} ]; then
		echo -ne "\n${INDENT}${THEME_DEBUG_COLOR} * DBG: $@${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn edevel()
## @brief display message to help development
## @param $message  the message to display
edevel() {
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_DEVEL_COLOR} * DEV: $@${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn eend()
## @brief display end message
## @param $rc  the status code to display
## @see returncodes.rc
eend() {
	local rc=${1}
	[ ! "${COLUMNS}" ] && COLUMNS=$(tput cols)
	esetx $((COLUMNS - ${#rc_done} - 16))
	case ${rc} in
		${RC_DONE})	 echo -ne "${rc_done}" >> ${STDOUT}
						;;
		${RC_FAILED})   echo -ne "${rc_failed}" >> ${STDOUT}
						;;
		${RC_RUNNING})  echo -ne "${rc_running}" >> ${STDOUT}
						;;
		${RC_MISSED})   echo -ne "${rc_missed}" >> ${STDOUT}
						;;
		${RC_SKIPPED})  echo -ne "${rc_skipped}" >> ${STDOUT}
						;;
		${RC_UNUSED})   echo -ne "${rc_unused}" >> ${STDOUT}
						;;
		${RC_UNKNOWN})  echo -ne "${rc_unknown}" >> ${STDOUT}
						;;
		${RC_DEAD})	 echo -ne "${rc_dead}" >> ${STDOUT}
						;;
		*)			  echo -ne "${rc_unknown}" >> ${STDOUT}
						;;
	esac

}

## @fn eenter()
## @brief display message when entering something (a function for example or a loop)
## @param $message  the message to display
eenter() {
	local message=${@}
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_ENTER_COLOR} >> ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn eerror()
## @brief display error message
## @param $message  the error message to display
eerror() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_ERROR_COLOR} * ERR: ${message} ${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn efatal()
## @brief display error message and exit
## @param $message  the error message to display
efatal() {
	eerror "$@\n"
	exit 1
}

## @fn einfo()
## @brief display info message
## @param $message  the message to display
einfo() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_INFO_COLOR} *${COLOR_NORMAL} ${message}" >> ${STDOUT}
}

## @fn eleave()
## @brief display message when leaving something (a function for example or a loop)
## @param $message  the message to display
eleave() {
	local message=${@}
	if [ ${DEVEL} ]; then
		echo -ne "\n${INDENT}${THEME_ENTER_COLOR} << ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn esubtitle()
## @brief display begin message
## @param $message  the message to display
esubtitle() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_TITLE_COLOR} * ${THEME_SUBTITLE_COLOR}${message}${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn etitle()
## @brief display a title
## @param $message  the title to display
etitle() {
	local message=${@}
	echo -e -n "\n${THEME_TITLE_COLOR} " >> ${STDOUT}
	for i in $(seq $((${#message}+6))); do echo -n '*'; done
	echo -e "\n ** ${message} ** ${COLOR_NORMAL}" >> ${STDOUT}
}

## @fn everbose()
## @brief display verbose message
## @param $message  the message to display
everbose() {
	local message=${@}
	if [ ${VERBOSE} ]; then
		echo -ne "\n${INDENT}${THEME_VERBOSE_COLOR} * ${message} ${COLOR_NORMAL}" >> ${STDOUT}
	fi
}

## @fn ewarn()
## @brief display warning message
## @param $message  the warning to display
ewarn() {
	local message=${@}
	echo -ne "\n${INDENT}${THEME_WARNING_COLOR} * ${message} ${COLOR_NORMAL}" >> ${STDOUT}
}

# ---------------------------------------------------------------------------------------

## @fn egetx()
## @brief get x position of current cursor
## @return (integer) current x position of cursor in terminal
## @see @url https://unix.stackexchange.com/questions/88296/get-vertical-cursor-position
egetx() {
	exec < /dev/tty
	oldstty=$(stty -g)
	stty raw -echo min 0
	## on my system, the following line can be replaced by the line below it
	echo -en "\033[6n" > /dev/tty
	## tput u7 > /dev/tty	# when TERM=xterm (and relatives)
	IFS=';' read -r -d R -a pos
	stty $oldstty
	## change from one-based to zero based so they work with: tput cup $row $col
	#row=$((${pos[0]:2} - 1))	# strip off the esc-[
	col=$((${pos[1]} - 1))

	#echo "(row,col): $row,$col"
	echo ${col}
}

## @fn esetx()
## @brief set x position of current cursor
## @param $x new position to set cursor to
## @see @url http://ascii-table.com/ansi-escape-sequences.php
esetx() {
	local new_x=${1}
	local cur_x=$(egetx)

	[ ! ${new_x} -ge 0 ] && return
	[ ! ${cur_x} -ge 0 ] && return

	if [ ${new_x} -gt ${cur_x} ]; then
		local step=$((new_x - cur_x))
		#echo -e "\033[${step}C ${new_x}"
		tput cuf ${step}
	else
		local step=$((cur_x - new_x))
		#echo -e "${new_x} \033[${step}D"
		tput cub ${step}
	fi
}

